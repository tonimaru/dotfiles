if 0 | finish | endif

if has('multi_byte')
  set encoding=utf-8
  set fileencoding=utf-8
  set fileencodings=utf-8,euc-jp,cp932
  set ambiwidth=double
endif

scriptencoding utf-8

if has('autocmd')
  augroup my_vimrc
    autocmd!
  augroup END
  command! -bang -nargs=* Au autocmd<bang> my_vimrc <args>
else
  command! -bang -nargs=* Au
endif

let s:is_mswin = has('win95') || has('win16') || has('win32') || has('win64')

function! s:mkdir(path)
  if !isdirectory(a:path)
    silent execute s:is_mswin ? '!md' : '!mkdir -p' a:path
  endif
endfunction

let s:home = expand('~')
let s:vimfiles_name = s:is_mswin ? 'vimfiles' : '.vim'
let s:vimfiles = expand(printf('%s/%s', s:home, s:vimfiles_name))

function! s:vimdir(dir)
  return expand(printf('%s/%s', s:vimfiles, a:dir))
endfunction

set swapfile
let s:swap_dir = s:vimdir('swap')
call s:mkdir(s:swap_dir)
execute printf('set directory=%s', s:swap_dir)

set backup
let s:backup_dir = s:vimdir('backup')
call s:mkdir(s:backup_dir)
execute printf('set backupdir=%s', s:backup_dir)

if has('persistent_undo')
  set undofile
  let s:undo_dir = s:vimdir('undo')
  call s:mkdir(s:undo_dir)
  execute printf('set undodir=%s', s:undo_dir)
endif

set number

set nowrap

set hidden

set keywordprg=

set list
set listchars=eol:$,tab:>-,trail:_,extends:>,precedes:>

set tabstop=2 shiftwidth=2 softtabstop=2
set expandtab smarttab
set autoindent

set ignorecase smartcase

set laststatus=2

set backspace=indent,eol,start

set foldlevel=100

execute printf('set verbosefile=%s', s:vimdir('verbosefile'))

if has('extra_search')
  set incsearch
  if has('vim_starting')
    set hlsearch
  endif
endif

if has('insert_expand')
  set completeopt-=preview
  if has('patch-7.4.775')
    set completeopt+=noselect,noinsert
  endif
endif

if has('smartindent')
  set smartindent
endif

if exists('+imdisable')
  set imdisable
endif

if has('multi_lang')
  set helplang=ja,en
endif

if has('gui_running')
  function! s:set_go()
    for v in split('aPAefimgtTrRlLbhvpF', '\zs')
      execute printf('set guioptions-=%s', v)
    endfor
    for v in split('cM', '\zs')
      execute printf('set guioptions+=%s', v)
    endfor
  endfunction
  call s:set_go()

  if filereadable(expand(s:home . '/.fonts/RictyDiscord-Regular.ttf'))
    set guifont=Ricty\ Discord\ 12
    set guifontwide=Ricty\ Discord\ 12
  endif

  if exists('+guiheadroom')
    set guiheadroom=0
  endif
endif

if exists('+clipboard')
  set clipboard=unnamed
  if has('unnamedplus')
    set clipboard+=unnamedplus
  endif
endif

if has('patch-7.4.785')
  set nofixeol
endif

nnoremap j gj
nnoremap gj j
nnoremap k gk
nnoremap gk k

nnoremap <Down> <C-w>j
nnoremap <Up> <C-w>k
nnoremap <Right> <C-w>l
nnoremap <Left> <C-w>h

nnoremap <S-Right> gt
nnoremap <S-Left> gT

nnoremap ; q:
vnoremap ; q:
nnoremap : ;
vnoremap : ;
nnoremap q; :
vnoremap q; :
nnoremap q: <Nop>
vnoremap q: <Nop>

nnoremap <silent> <Esc><Esc> :nohls<CR>

map <Space> [prefix]
noremap [prefix] <Nop>

nnoremap <silent> [prefix]ee :<C-u>e $MYVIMRC<CR>
nnoremap <silent> [prefix]er :<C-u>so $MYVIMRC<CR>

" http://nanabit.net/blog/2009/07/04/vim-replace-motion/
" https://github.com/kana/vim-operator-replace
function! s:operator_replace(type)
  let sel_save = &selection
  let p_save = &paste
  let &selection = 'inclusive'
  set paste

  let reg = v:register !=# '' ? v:register : '"'
  if a:type =~# '\v\C^[vV]$'
    execute printf('normal! `<%s`>"_c%s%s', a:type, "\<C-r>", reg)
  else
    execute printf('normal! `[v`]"_c%s%s', "\<C-r>", reg)
  endif

  let &paste = p_save
  let &selection = sel_save
endfunction
nnoremap <silent> s :<C-u>set opfunc=<SID>operator_replace<CR>g@
vnoremap <silent> s :<C-u>call <SID>operator_replace(visualmode())<CR>

Au CmdwinEnter * call s:init_cmdwin()
function! s:init_cmdwin()
  nnoremap <buffer><silent><nowait> <ESC> <C-w>c
  vnoremap <buffer><silent><nowait> <ESC> <C-w>c
  nnoremap <buffer><silent><nowait> q <C-w>c
  vnoremap <buffer><silent><nowait> q <C-w>c
  startinsert!
endfunction

Au FileType help noremap <buffer><nowait> q <C-w>c

Au FileType javascript,coffee set tabstop=2 shiftwidth=2

Au WinEnter * checktime

let s:bundle_path = s:vimdir('bundle')
let s:neobundle_path = expand(printf('%s/%s', s:bundle_path, 'neobundle.vim'))
" TODO
function! s:neobundle_install()
  if confirm('install neobundle?', "yes\nno", 1) == 1
    call s:mkdir(s:bundle_path)
    silent execute '!git clone http://github.com/Shougo/neobundle.vim' s:neobundle_path
    return 1
  else
    return 0
  endif
endfunction
function! s:neobundle_installed()
  return filereadable(expand(s:neobundle_path . '/README.md'))
endfunction

if !s:neobundle_installed()
  if !s:neobundle_install()
    finish
  endif
  if !s:neobundle_installed()
    echo 'neobundle install failed'
    finish
  endif
endif

if has('vim_starting')
  execute 'set runtimepath+='.s:neobundle_path
endif

call neobundle#begin(s:bundle_path)

NeoBundle 'airblade/vim-gitgutter'
NeoBundle 'altercation/vim-colors-solarized'
NeoBundle 'daisuzu/translategoogle.vim'
NeoBundle 'itchyny/lightline.vim'
NeoBundle 'kana/vim-niceblock'
NeoBundle 'kana/vim-operator-user'
NeoBundle 'kana/vim-repeat'
NeoBundle 'kana/vim-textobj-entire', {'depends': 'kana/vim-textobj-user'}
NeoBundle 'kana/vim-textobj-line', {'depends': 'kana/vim-textobj-user'}
NeoBundle 'kana/vim-textobj-user'
NeoBundle 'osyo-manga/vim-brightest'
NeoBundle 'osyo-manga/vim-textobj-multiblock'
NeoBundle 'rust-lang/rust.vim'
NeoBundle 'Shougo/neomru.vim'
NeoBundle 'thinca/vim-prettyprint'
NeoBundle 'thinca/vim-qfreplace'
NeoBundle 'thinca/vim-template'
NeoBundle 'tpope/vim-fugitive'
NeoBundle 'tyru/caw.vim'
NeoBundle 'tyru/open-browser.vim'
NeoBundle 'vim-jp/vimdoc-ja'
NeoBundle 'wavded/vim-stylus'
NeoBundle 'Yggdroot/indentLine'
NeoBundleFetch 'Shougo/neobundle.vim'
NeoBundleLazy 'alpaca-tc/beautify.vim', {'build': {'others': 'npm i -g js-beautify'}, 'disabled': !executable('npm')}
NeoBundleLazy 'cohama/agit.vim'
NeoBundleLazy 'cohama/lexima.vim', {'autoload': {'insert': 1}}
NeoBundleLazy 'cohama/vim-hier', {'autoload': {'on_source': ['vim-watchdogs']}}
NeoBundleLazy 'dag/vim2hs', {'autoload': {'filetypes': ['haskell']}}
NeoBundleLazy 'deris/vim-rengbang'
NeoBundleLazy 'digitaltoad/vim-jade', {'autoload': {'filetypes': ['jade']}}
NeoBundleLazy 'eagletmt/neco-ghc', {'autoload': {'filetypes': ['haskell']}, 'disabled': !executable('cabal') || !executable('ghc-mod')}
NeoBundleLazy 'elzr/vim-json', {'autoload': {'filetypes': ['json']}}
NeoBundleLazy 'h1mesuke/vim-alignta'
NeoBundleLazy 'hail2u/vim-css3-syntax', {'autoload': {'filetypes': ['css']}}
NeoBundleLazy 'haya14busa/incsearch.vim', {'autoload': {'mappings': ['<Plug>(incsearch']}}
NeoBundleLazy 'haya14busa/vim-asterisk', {'autoload': {'mappings': ['<Plug>(asterisk']}}
NeoBundleLazy 'ingydotnet/yaml-vim', {'autoload': {'filetypes': ['yaml']}}
NeoBundleLazy 'jelera/vim-javascript-syntax', {'autoload': {'filetypes': ['javascript']}}
NeoBundleLazy 'kana/vim-smartword', {'autoload': {'mappings': ['<Plug>(smartword']}}
NeoBundleLazy 'kannokanno/previm'
NeoBundleLazy 'kannokanno/vim-helpnew'
NeoBundleLazy 'katono/rogue.vim'
NeoBundleLazy 'KazuakiM/vim-qfsigns', {'autoload': {'on_source': ['vim-watchdogs']}}
NeoBundleLazy 'kchmck/vim-coffee-script', {'autoload': {'filetypes': ['coffee']}}
NeoBundleLazy 'lambdalisue/vim-gista', {'autoload': {'unite_sources': ['gista']}}
NeoBundleLazy 'leafgarland/typescript-vim', {'autoload': {'filetypes': ['typescript']}}
NeoBundleLazy 'machakann/vim-sandwich', {'autoload': {'mappings': ['<Plug>(operator-sandwich']}}
NeoBundleLazy 'marijnh/tern_for_vim', {'build': {'others': 'npm install && npm install tern-coffee'}, 'autoload': {'filetypes': ['javascript', 'coffee']}, 'disabled': !executable('npm')}
NeoBundleLazy 'mattn/emmet-vim', {'autoload': {'insert': 1}}
NeoBundleLazy 'mattn/webapi-vim'
NeoBundleLazy 'mhinz/vim-sayonara'
NeoBundleLazy 'osyo-manga/shabadou.vim', {'depends': ['thinca/vim-quickrun']}
NeoBundleLazy 'osyo-manga/unite-quickfix', {'autoload': {'unite_sources': ['quickfix']}}
NeoBundleLazy 'osyo-manga/unite-quickrun_config', {'depends': 'thinca/vim-quickrun', 'autoload': {'unite_sources': ['quickrun_config']}}
NeoBundleLazy 'osyo-manga/vim-anzu', {'autoload': {'mappings': ['<Plug>(anzu']}}
NeoBundleLazy 'osyo-manga/vim-hopping'
NeoBundleLazy 'osyo-manga/vim-marching', {'autoload': {'filetypes': ['cpp']}}
NeoBundleLazy 'osyo-manga/vim-precious', {'depends': ['Shougo/context_filetype.vim'], 'autoload': {'filetypes': ['vim', 'markdown']}}
NeoBundleLazy 'osyo-manga/vim-snowdrop', {'autoload': {'filetypes': ['c', 'cpp']}}
NeoBundleLazy 'osyo-manga/vim-watchdogs', {'depends': ['thinca/vim-quickrun', 'osyo-manga/shabadou.vim', 'Shougo/vimproc.vim'], 'autoload': {'filetypes': ['all']}}
NeoBundleLazy 'othree/html5.vim', {'autoload': {'filetypes': ['html']}}
NeoBundleLazy 'othree/javascript-libraries-syntax.vim', {'filetypes': ['javascript', 'coffee', 'typescript']}
NeoBundleLazy 'othree/tern_for_vim_coffee', {'autoload': {'on_source': ['tern_for_vim']}, 'disabled': !executable('npm')}
NeoBundleLazy 'pangloss/vim-javascript', {'autoload': {'on_source': ['vim-javascript-syntax']}}
NeoBundleLazy 'Shougo/context_filetype.vim'
NeoBundleLazy 'Shougo/deoplete.nvim', {'autoload': {'insert': 1}, 'disabled': !has('nvim')}
NeoBundleLazy 'Shougo/junkfile.vim', {'autoload': {'unite_sources': ['junkfile', 'junkfile/new']}}
NeoBundleLazy 'Shougo/neco-syntax', {'autoload': {'on_source': ['neocomplete.vim', 'deoplete.nvim']}}
NeoBundleLazy 'Shougo/neco-vim', {'autoload': {'on_source': ['neocomplete.vim', 'deoplete.nvim']}}
NeoBundleLazy 'Shougo/neocomplete.vim', {'autoload': {'insert': 1}, 'disabled': has('nvim') || !has('lua')}
NeoBundleLazy 'Shougo/neoinclude.vim', {'autoload': {'on_source': ['neocomplete.vim', 'deoplete.nvim']}}
NeoBundleLazy 'Shougo/neosnippet.vim', {'autoload': {'insert': 1}}
NeoBundleLazy 'Shougo/unite.vim'
NeoBundleLazy 'Shougo/vimfiler.vim', {'depends': ['Shougo/unite.vim']}
NeoBundleLazy 'Shougo/vimproc.vim', {'build': {'others': 'make'}}
NeoBundleLazy 'Shougo/vimshell.vim', {'depends': ['Shougo/vimproc.vim', 'Shougo/unite.vim']}
NeoBundleLazy 'Shougo/vinarise.vim'
NeoBundleLazy 't9md/vim-textmanip', {'autoload': {'mappings': ['<Plug>(textmanip']}}
NeoBundleLazy 'thinca/vim-quickrun', {'complete' : 'customlist,quickrun#complete', 'depends': ['osyo-manga/quickrun-outputter-replace_region']}
NeoBundleLazy 'thinca/vim-ref'
NeoBundleLazy 'thinca/vim-scouter'
NeoBundleLazy 'tonimaru/vim-qfecho', {'autoload': {'on_source': ['vim-watchdogs']}}
NeoBundleLazy 'tonimaru/vim-unite-ilist', {'autoload': {'unite_sources': ['ilist']}}
NeoBundleLazy 'tyru/capture.vim'
NeoBundleLazy 'tyru/eskk.vim', {'autoload': {'insert': 1}}
NeoBundleLazy 'tyru/restart.vim', {'gui': 1}
NeoBundleLazy 'ujihisa/ref-hoogle', {'autoload': {'on_source': ['vim-ref']}, 'disabled': !executable('cabal') || !executable('hoogle')}
NeoBundleLazy 'vim-jp/cpp-vim', {'autoload': {'filetypes': ['cpp']}}
NeoBundleLazy 'vim-jp/vital.vim'


nmap [prefix]u [unite]
nnoremap [unite] <Nop>
if neobundle#tap('unite.vim')

  let g:unite_source_grep_max_candidates = 10000
  if executable('ag')
    let g:unite_source_grep_command = 'ag'
    let g:unite_source_grep_default_opts = ''
    let g:unite_source_grep_default_opts = ' --vimgrep'
    let g:unite_source_grep_default_opts .= ' --all-types'
    let g:unite_source_grep_default_opts .= ' --hidden'
    let g:unite_source_grep_default_opts .= ' --ignore-case'
    let g:unite_source_grep_default_opts .= ' --ignore ''.git'''
    let g:unite_source_grep_default_opts .= ' --ignore ''.hg'''
    let g:unite_source_grep_default_opts .= ' --ignore ''.svn'''
    let g:unite_source_grep_recursive_opt = ''
  endif

  let g:unite_source_find_max_candidates = 2000

  nnoremap <silent> [unite]bf :<C-u>Unite buffer<CR>
  nnoremap <silent> [unite]bu :<C-u>Unite neobundle/update:all<CR>
  nnoremap <silent> [unite]c :<C-u>Unite quickfix<CR>
  nnoremap <silent> [unite]fm :<C-u>Unite neomru/file<CR>
  nnoremap <silent> [unite]ga :<C-u>Unite grep -create -auto-preview -tab<CR>
  nnoremap <silent> [unite]gr :<C-u>Unite grep -create<CR>
  nnoremap <silent> [unite]il :<C-u>Unite ilist<CR>
  nnoremap <silent> [unite]l :<C-u>Unite line<CR>
  nnoremap <silent> [unite]j :<C-u>Unite junkfile/new junkfile<CR>
  nnoremap <silent> [unite]q :<C-u>Unite quickrun_config<CR>

  Au FileType unite call s:ft_unite()
  function! s:ft_unite()
    map <buffer><nowait> q <Plug>(unite_exit)
    map <buffer><nowait> <C-g> <Plug>(unite_exit)

    map <buffer><nowait> Q <Plug>(unite_all_exit)|
    map <buffer><nowait> g<C-g> <Plug>(unite_all_exit)|
  endfunction

  function! neobundle#tapped.hooks.on_post_source(bundle)
    call unite#custom#profile('default', 'context', { 'start_insert': 1, 'direction': 'botright' })
    call unite#custom#profile('source/line', 'context', { 'direction': 'topleft' })
    call unite#custom#profile('source/ilist', 'context', { 'direction': 'topleft', 'no_empty': 1 })
    call unite#custom#profile('source/grep', 'context', { 'no_quit' : 1, 'no_empty': 1 })
    call unite#custom#profile('source/neobundle/update', 'context', { 'start_insert': 0, 'log': 1, ' multi_line': 1, })
  endfunction

  call neobundle#untap()
endif

nmap [prefix]vf [vimfiler]
nnoremap [vimfiler] <Nop>
if neobundle#tap('vimfiler.vim')

  let g:vimfiler_safe_mode_by_default = 0
  let g:vimfiler_enable_auto_cd       = 1

  nnoremap <silent> [vimfiler]; :<C-u>VimFiler<CR>
  nnoremap <silent> [vimfiler]+ :<C-u>VimFiler -create<CR>
  nnoremap <silent> [vimfiler]p :<C-u>VimFiler -split<CR>
  nnoremap <silent> [vimfiler]P :<C-u>VimFiler -create -split<CR>
  nnoremap <silent> [vimfiler]j :<C-u>VimFilerExplorer<CR>

  Au FileType vimfiler call s:ft_vimfiler()
  function! s:vimfiler_key_wrap(plug)
    if empty(vimfiler#get_marked_files())
      call feedkeys("\<Plug>(vimfiler_toggle_mark_current_line)", 'm')
    endif
    call feedkeys(a:plug, 'm')
  endfunction

  function! s:ft_vimfiler()
    nmap <buffer><expr><nowait> c <SID>vimfiler_key_wrap("\<Plug>(vimfiler_copy_file)")
    nmap <buffer><expr><nowait> m <SID>vimfiler_key_wrap("\<Plug>(vimfiler_move_file)")
    nmap <buffer><expr><nowait> d <SID>vimfiler_key_wrap("\<Plug>(vimfiler_delete_file)")
    nmap <buffer><expr><nowait> r <SID>vimfiler_key_wrap("\<Plug>(vimfiler_rename_file)")

    map <buffer><nowait> q <Plug>(vimfiler_hide)
  endfunction

  function! neobundle#tapped.hooks.on_post_source(bundle)
    NeoBundleSource vimshell.vim
  endfunction

  call neobundle#untap()
endif

nmap [prefix]vs [vimshell]
nnoremap [vimshell] <Nop>
if neobundle#tap('vimshell.vim')

  nnoremap <silent> [vimshell]; :<C-u>VimShell<CR>
  nnoremap <silent> [vimshell]+ :<C-u>VimShell -create<CR>

  call neobundle#untap()
endif

map [prefix]g [fugitive]
nnoremap [fugitive] <Nop>
if neobundle#tap('vim-fugitive')

  nnoremap [fugitive]b :<C-u>Gblame<CR>
  nnoremap [fugitive]cd :<C-u>Gcd<CR>
  nnoremap [fugitive]d :<C-u>Gvdiff<CR>
  nnoremap [fugitive]p :<C-u>Gpush origin master
  nnoremap [fugitive]s :<C-u>Gstatus<CR>
  vnoremap [fugitive]b :Gblame<CR>

  call neobundle#untap()
endif

map [prefix]q [quickrun]
noremap [quickrun] <Nop>
if neobundle#tap('vim-quickrun')

  let g:quickrun_config = {}

  let g:quickrun_config['_'] = {}
  let g:quickrun_config['_']['runner'] = 'vimproc'
  let g:quickrun_config['_']['runner/vimproc/updatetime'] = 40

  let g:quickrun_config['json'] = {'type': executable('jq') ? 'json/jq' : executable('json2yaml') ? 'json/json2yaml' : ''}
  let g:quickrun_config['json/jq'] = {'command': 'jq', 'exec': '%c "." %s', 'outputter/buffer/filetype': 'json'}
  let g:quickrun_config['json/json2yaml'] = {'command': 'json2yaml', 'exec': '%c %s', 'outputter/buffer/filetype': 'yaml'}

  let g:quickrun_config['yaml'] = {'type': executable('yaml2json') ? 'yaml/yaml2json' : ''}
  let g:quickrun_config['yaml/yaml2json'] = {'command': 'yaml2json', 'exec': '%c %s', 'outputter/buffer/filetype': 'json'}

  let g:quickrun_config['scala'] = {'type': executable('scala') ? 'scala/process_manager' : ''}

  let s:clang_exe = expand($HOME.'/local/llvm/bin/clang++')
  let s:clang_exe = executable(s:clang_exe) ? s:clang_exe : 'clang++'

  let  s:conf_base = {}
  function! s:conf_base.set_to(config) dict
    return self.set_to_impl(deepcopy(a:config))
  endfunction

  function! s:new_conf(name, ...)
    let config = extend({'name': a:name}, s:conf_base)
    if a:0 != 0
      let config['set_to_impl'] = a:1
    endif
    return config
  endfunction

  let s:pp = s:new_conf('pp')
  function! s:pp.set_to_impl(config) dict
    let a:config['cmdopt'] = get(a:config, 'cmdopt', '').' -E'
    let a:config['exec'] = '%c %o %s'
    return a:config
  endfunction

  let s:asm = s:new_conf('asm')
  function! s:asm.set_to_impl(config) dict
    let a:config['cmdopt'] = get(a:config, 'cmdopt', '').' -S'
    let a:config['exec'] = ['%c %o %s -o -']
    return a:config
  endfunction

  function! s:std(config) dict
    let a:config['cmdopt'] = get(a:config, 'cmdopt', '').' -std='.self['name']
    return a:config
  endfunction

  let s:c11             = s:new_conf('c11', function('s:std'))
  let s:c1x             = s:new_conf('c1x', function('s:std'))
  let s:c89             = s:new_conf('c89', function('s:std'))
  let s:c90             = s:new_conf('c90', function('s:std'))
  let s:c99             = s:new_conf('c99', function('s:std'))
  let s:c9x             = s:new_conf('c9x', function('s:std'))
  let s:gnu11           = s:new_conf('gnu11', function('s:std'))
  let s:gnu1x           = s:new_conf('gnu1x', function('s:std'))
  let s:gnu89           = s:new_conf('gnu89', function('s:std'))
  let s:gnu90           = s:new_conf('gnu90', function('s:std'))
  let s:gnu99           = s:new_conf('gnu99', function('s:std'))
  let s:gnu9x           = s:new_conf('gnu9x', function('s:std'))
  let s:iso9899_1990    = s:new_conf('iso9899:1990', function('s:std'))
  let s:iso9899_199409  = s:new_conf('iso9899:199409', function('s:std'))
  let s:iso9899_1999    = s:new_conf('iso9899:1999', function('s:std'))
  let s:iso9899_199x    = s:new_conf('iso9899:199x', function('s:std'))
  let s:iso9899_2011    = s:new_conf('iso9899:2011', function('s:std'))

  let s:cxx03    = s:new_conf('c++03', function('s:std'))
  let s:cxx0x    = s:new_conf('c++0x', function('s:std'))
  let s:cxx11    = s:new_conf('c++11', function('s:std'))
  let s:cxx14    = s:new_conf('c++14', function('s:std'))
  let s:cxx1y    = s:new_conf('c++1y', function('s:std'))
  let s:cxx1z    = s:new_conf('c++1z', function('s:std'))
  let s:cxx98    = s:new_conf('c++98', function('s:std'))
  let s:gnuxx03  = s:new_conf('gnu++03', function('s:std'))
  let s:gnuxx0x  = s:new_conf('gnu++0x', function('s:std'))
  let s:gnuxx11  = s:new_conf('gnu++11', function('s:std'))
  let s:gnuxx14  = s:new_conf('gnu++14', function('s:std'))
  let s:gnuxx1y  = s:new_conf('gnu++1y', function('s:std'))
  let s:gnuxx1z  = s:new_conf('gnu++1z', function('s:std'))
  let s:gnuxx98  = s:new_conf('gnu++98', function('s:std'))

  let s:libcxx_libsupcxx_path = expand($HOME.'/local/llvm/libcxx_libsupcxx')
  let s:libcxx_libcxxabi_path = expand($HOME.'/local/llvm/libcxx_libcxxabi')
  let s:libcxxabi_path = expand($HOME.'/local/llvm/libcxxabi')

  " TODO libcxx path
  let s:libcxx_libsupcxx = s:new_conf('libcxx_libsupcxx')
  function! s:libcxx_libsupcxx.set_to_impl(config) dict
    let a:config['cmdopt'] = get(a:config, 'cmdopt', '').printf(' -stdlib=libc++ -I%s/include/c++/v1', s:libcxx_libsupcxx_path)

    if a:config['cmdopt'] !~# '\v\C(^|\s+)-[ES](\s+|$)'
      let a:config['cmdopt'] .= printf(' -L%s/lib', s:libcxx_libsupcxx_path)
    endif
    return a:config
  endfunction

  let s:libcxx_libcxxabi = s:new_conf('libcxx_libcxxabi')
  function! s:libcxx_libcxxabi.set_to_impl(config) dict
    let a:config['cmdopt'] = get(a:config, 'cmdopt', '').printf(' -stdlib=libc++ -I%s/include/c++/v1', s:libcxx_libcxxabi_path)

    if a:config['cmdopt'] !~# '\v\C(^|\s+)-[ES](\s+|$)'
      let a:config['cmdopt'] .= printf(' -L%s/lib -L%s/lib -lc++abi', s:libcxx_libcxxabi_path, s:libcxxabi_path)
    endif
    return a:config
  endfunction

  let s:cdst = [s:pp, s:asm]
  let s:cstd = [s:c11, s:c1x, s:c89, s:c90, s:c99, s:c9x, s:gnu11, s:gnu1x, s:gnu89, s:gnu90, s:gnu99, s:gnu9x, s:iso9899_1990, s:iso9899_199409, s:iso9899_1999, s:iso9899_199x, s:iso9899_2011]

  let s:cxxdst = [s:pp, s:asm]
  let s:cxxstd = [s:cxx03, s:cxx0x, s:cxx11, s:cxx14, s:cxx1y, s:cxx1z, s:cxx98, s:gnuxx03, s:gnuxx0x, s:gnuxx11, s:gnuxx14, s:gnuxx1y, s:gnuxx1z, s:gnuxx98]
  let s:cxxlib = [s:libcxx_libsupcxx, s:libcxx_libcxxabi]

  function! s:_apply(current, arg)
    let config = extend(a:arg.set_to(a:current['config']), {'type': a:current['name']}, 'force')
    let name = printf('%s/%s', a:current['name'], a:arg['name'])
    return {'name': name, 'config': config}
  endfunction

  function! s:_build_impl(current, args_list)
    let r = []
    let next = copy(a:args_list)
    for args in a:args_list
      let next = next[1:]
      for arg in args
        let v = s:_apply(a:current, arg)
        call add(r, v)
        call extend(r, s:_build_impl(v, next))
      endfor
    endfor
    return r
  endfunction

  function! s:_set_quickrun_config(root, arg)
    let built = s:_build_impl(a:root, a:arg)
    for v in built
      let g:quickrun_config[v['name']] = v['config']
    endfor
  endfunction

  function! s:set_quickrun_configs()
    if executable('gcc')
      call s:_set_quickrun_config({'name': 'c/gcc', 'config': {}}, [s:cdst, s:cstd])
    endif
    if executable('g++')
      call s:_set_quickrun_config({'name': 'cpp/g++', 'config': {}}, [s:cxxdst, s:cxxstd])
    endif
    if executable(s:clang_exe)
      " TODO libcxx path
      let clang_arg = isdirectory($HOME.'/local/llvm') ? [s:cxxdst, s:cxxstd, s:cxxlib] : [s:cxxdst, s:cxxstd]

      let cpp_includes = join(map([$HOME.'/local/src/cpp/boost_1_58_0/', ], '''-I''.v:val'), ' ')
      let cpp_lib_path = '-L'.$HOME.'/local/src/cpp/boost_1_58_0/stage/clang/lib'
      let cpp_libs = join(map(['boost_atomic', 'boost_thread', 'boost_system', 'python2.7' , 'pthread'], '''-l''.v:val'), ' ')
      let cpp_opt = printf('%s %s %s', cpp_includes, cpp_lib_path, cpp_libs)
      call s:_set_quickrun_config({'name': 'cpp/clang++', 'config': {'command': s:clang_exe, 'cmdopt': cpp_opt}}, clang_arg)
    endif
  endfunction
  call s:set_quickrun_configs()

  nmap [quickrun] <Plug>(quickrun)

  call neobundle#untap()
endif

if neobundle#tap('vim-watchdogs')

  let g:quickrun_config['watchdogs_checker/_' ] = {}
  let g:quickrun_config['watchdogs_checker/_' ]['runner/vimproc/updatetime'] = 40
  let g:quickrun_config['watchdogs_checker/_' ]['outputter/quickfix/open_cmd'] = ''

  let g:quickrun_config['watchdogs_checker/_' ]['hook/qfsigns_update/enable_exit'] = 1

  let g:quickrun_config['c/watchdogs_checker'] = {'type' : executable('clang') ? 'watchdogs_checker/clang' : executable('gcc')   ? 'watchdogs_checker/gcc' : ''}

  let g:quickrun_config['watchdogs_checker/ghc-mod'] = {'cmdopt': '-fno-warn-type-defaults'}

  " https://github.com/rust-lang/rust.vim/blob/master/syntax_checkers/rust/rustc.vim
  let g:quickrun_config['rust/watchdogs_checker'] = {'type': executable('rustc') ? 'watchdogs_checker/rustc' : ''}
  let g:quickrun_config['watchdogs_checker/rustc'] = {}
  let g:quickrun_config['watchdogs_checker/rustc']['command'] = 'rustc'
  let g:quickrun_config['watchdogs_checker/rustc']['exec'] = '%c %o -Zparse-only %s:p'
  let g:quickrun_config['watchdogs_checker/rustc']['errorformat'] = '%E%f:%l:%c: %\d%#:%\d%# %.%\{-}error:%.%\{-} %m,%W%f:%l:%c: %\d%#:%\d%# %.%\{-}warning:%.%\{-} %m,%C%f:%l %m,%-Z%.%#'

  let g:watchdogs_check_BufWritePost_enable = 1
  let g:watchdogs_check_BufWritePost_enable_on_wq = 0

  function! neobundle#tapped.hooks.on_post_source(bundle)
    call watchdogs#setup(g:quickrun_config)
  endfunction

  call neobundle#untap()
endif

map [prefix]b [beautify]
noremap [beautify] <Nop>
if neobundle#tap('beautify.vim')

  if executable('npm')
    nnoremap [beautify] :<C-u>Beautify<CR>
    vnoremap [beautify] :Beautify<CR>
  endif

  call neobundle#untap()
endif

map [prefix]res [restart]
noremap [restart] <Nop>
if neobundle#tap('restart.vim')

  noremap <silent> [restart] :<C-u>Restart<CR>

  call neobundle#untap()
endif

nmap [prefix]ref [ref]
nnoremap [ref] <Nop>
if neobundle#tap('vim-ref')

  nnoremap [ref]m :<C-u>Ref man<Space>
  nnoremap [ref]h :<C-u>Ref hoogle<Space>

  call neobundle#untap()
endif

nmap [prefix]sa [sayonara]
nnoremap [sayonara] <Nop>
if neobundle#tap('vim-sayonara')

  nnoremap <silent> [sayonara]y :<C-u>Sayonara<cr>
  nnoremap <silent> [sayonara]; :<C-u>Sayonara!<cr>

  call neobundle#untap()
endif

if neobundle#tap('neocomplete.vim')

  let g:neocomplete#enable_at_startup = 1
  let g:neocomplete#enable_auto_select = 0

  if !exists('g:neocomplete#force_omni_input_patterns')
    let g:neocomplete#force_omni_input_patterns = {}
  endif
  let g:neocomplete#force_omni_input_patterns['c'] = '\v\C%(<\h\w*>|]|\)|^)\zs\s*%(\.|-\>)'
  let g:neocomplete#force_omni_input_patterns['cpp'] = '\v%(<\h\w*>|^|[;,()<>])\s*((::|\.|-\>)(<\h\w*>)?)+|^\s*<\h\w*>'

  if executable('npm')
    let g:neocomplete#force_omni_input_patterns['javascript'] = '[^. \t]\.\w*'
    let g:neocomplete#force_omni_input_patterns['coffee'] = '[^. \t]\.\w*'
  endif

  inoremap <expr> <C-L> neocomplete#complete_common_string()

  call neobundle#untap()
endif

if neobundle#tap('lexima.vim')
  let g:lexima_no_default_rules = 1

  function! neobundle#tapped.hooks.on_post_source(bundle)
    call lexima#set_default_rules()

    let n = neobundle#config#get('neocomplete.vim')
    if !empty(n) && !n['disabled'] && isdirectory(n['path'])
      call lexima#insmode#map_hook('before', '<CR>', "\<C-r>=neocomplete#close_popup()\<CR>")
    endif
  endfunction

  call neobundle#untap()
endif

if neobundle#tap('vim2hs')

  let g:haskell_conceal = 0

  call neobundle#untap()
endif

if neobundle#tap('vim-brightest')

  let g:brightest#pattern = '\w\+'
  let g:brightest#highlight = {}
  let g:brightest#highlight['group'] = 'VimrcKeywordHighlightBold'
  let g:brightest#highlight['format'] = '\v\C(^|\W\zs)%s(\ze\W|$)'
  let g:brightest#enable_highlight_all_window = 1

  call neobundle#untap()
endif

if neobundle#tap('vim-marching')

  let g:marching_clang_command_option = '-std=c++1y'
  let g:marching_enable_neocomplete = 1
  if !executable('clang')
    let g:marching_backend = 'sywnc_wandbox'
  endif

  call neobundle#untap()
endif

if neobundle#tap('vim-snowdrop')

  " TODO path
  if !filereadable('libclang.so') && filereadable(expand($HOME.'/local/llvm/lib/libclang.so'))
    let g:snowdrop#libclang_directory = expand($HOME.'/local/llvm/lib')
  endif

  call neobundle#untap()
endif

if neobundle#tap('rogue.vim')

  let g:rogue#japanese = 1

  call neobundle#untap()
endif

if neobundle#tap('vim-json')

  let g:vim_json_syntax_conceal = 0

  call neobundle#untap()
endif

if neobundle#tap('vim-asterisk')
  let g:asterisk#keeppos = 1

  call neobundle#untap()
endif

if neobundle#tap('vim-anzu')

  let g:anzu_status_format = '%p(%i/%l)'
  let g:anzu_enable_CursorMoved_AnzuUpdateSearchStatus = 1

  call neobundle#untap()
endif

if neobundle#tap('incsearch.vim')

  map /  <Plug>(incsearch-forward)
  map ?  <Plug>(incsearch-backward)
  map g/ <Plug>(incsearch-stay)

  call neobundle#untap()
endif

if neobundle#tap('vim-asterisk') && neobundle#tap('vim-anzu')

  map *   <Plug>(asterisk-z*)<Plug>(anzu-echo-search-status)
  map #   <Plug>(asterisk-z#)<Plug>(anzu-echo-search-status)
  map g*  <Plug>(asterisk-gz*)<Plug>(anzu-echo-search-status)
  map g#  <Plug>(asterisk-gz#)<Plug>(anzu-echo-search-status)

  call neobundle#untap()
endif

if neobundle#tap('vim-smartword')

  map w  <Plug>(smartword-w)
  map b  <Plug>(smartword-b)
  map e  <Plug>(smartword-e)
  map ge  <Plug>(smartword-ge)

  call neobundle#untap()
endif

if neobundle#tap('neosnippet.vim')

  let g:neosnippet#disable_runtime_snippets = { '_': 1, }
  let g:neosnippet#snippets_directory = s:vimdir('snippets')

  imap <C-K> <Plug>(neosnippet_expand_or_jump)
  smap <C-K> <Plug>(neosnippet_expand_or_jump)
  imap <C-J> <Plug>(neosnippet_jump_or_expand)
  smap <C-J> <Plug>(neosnippet_jump_or_expand)

  call neobundle#untap()
endif

if neobundle#tap('vim-textmanip')

  xmap <C-j> <Plug>(textmanip-move-down)
  xmap <C-k> <Plug>(textmanip-move-up)
  xmap <C-h> <Plug>(textmanip-move-left)
  xmap <C-l> <Plug>(textmanip-move-right)

  call neobundle#untap()
endif

if neobundle#tap('eskk.vim')

  let g:eskk#no_default_mappings = 1
  let g:eskk#enable_completion = 1
  let g:eskk#max_candidates = 100
  let g:eskk#start_completion_length = 2
  let g:eskk#auto_save_dictionary_at_exit = 0

  if executable('google-ime-skk')
    let g:eskk#server = { 'host': 'localhost', 'port': 55100, }

    call system('ps ax | grep google-ime-skk | grep -v grep')
    if v:shell_error
      silent! !google-ime-skk &
    endif
  endif

  imap <C-X>j <Plug>(eskk:toggle)
  imap <C-X><C-J> <Plug>(eskk:toggle)
  cmap <C-X>j <Plug>(eskk:toggle)
  cmap <C-X><C-J> <Plug>(eskk:toggle)

  call neobundle#untap()
endif

if neobundle#tap('vim-textobj-multiblock')

  omap ab <Plug>(textobj-multiblock-a)
  omap ib <Plug>(textobj-multiblock-i)

  call neobundle#untap()
endif

if neobundle#tap('vim-sandwich')
  let g:operator_sandwich_no_default_key_mappings = 1

  nmap ys <Plug>(operator-sandwich-add)
  nmap ds <Plug>(operator-sandwich-delete)<Plug>(textobj-sandwich-query-a)
  nmap cs <Plug>(operator-sandwich-replace)<Plug>(textobj-sandwich-query-a)
  nmap dsb <Plug>(operator-sandwich-delete)<Plug>(textobj-sandwich-auto-a)
  nmap csb <Plug>(operator-sandwich-replace)<Plug>(textobj-sandwich-auto-a)
  xmap S <Plug>(operator-sandwich-add)
  xmap D <Plug>(operator-sandwich-delete)<Plug>(textobj-sandwich-query-a)
  xmap C <Plug>(operator-sandwich-replace)<Plug>(textobj-sandwich-query-a)

  call neobundle#untap()
endif

if neobundle#tap('vim-hopping')
  let g:hopping#keymapping = {
        \   "\<C-n>" : '<Over>(hopping-next)',
        \   "\<C-p>" : '<Over>(hopping-prev)',
        \   "\<C-y>" : '<Over>(scroll-y)',
        \   "\<C-u>" : '<Over>(scroll-u)',
        \   "\<C-f>" : '<Over>(scroll-f)',
        \   "\<C-e>" : '<Over>(scroll-e)',
        \   "\<C-d>" : '<Over>(scroll-d)',
        \   "\<C-b>" : '<Over>(scroll-b)',
        \ }
  call neobundle#untap()
endif

if neobundle#tap('vim-template')
  Au FileType * execute 'TemplateLoad /filetype/' . &l:filetype
  call neobundle#untap()
endif

if neobundle#tap('deoplete.nvim')
  let g:deoplete#enable_at_startup = 1
  call neobundle#untap()
endif

if neobundle#tap('vim-qfecho')
  let g:qfecho_enable_at_startup = 1
  call neobundle#untap()
endif

call neobundle#end()

runtime macros/matchit.vim

filetype plugin indent on

set synmaxcol=210
syntax on
set background=dark

if !has('gui_running')
  if $COLORTERM ==# 'gnome-terminal'
    set t_Co=256
  endif
endif

if neobundle#tap('vim-colors-solarized')

  if !has('gui_running')
    let g:solarized_termcolors=&t_Co
  endif
  colorscheme solarized

  call neobundle#untap()
endif

if !has('vim_starting') && neobundle#tap('indentLine')
  IndentLinesReset
  call neobundle#untap()
endif

highlight VimrcKeywordHighlight term=bold ctermfg=224 guifg=#ffd4c9
highlight VimrcKeywordHighlightBold term=bold cterm=bold ctermfg=224 gui=bold guifg=#ffd4c9

let g:hier_highlight_group_qf  = 'qf_error_ucurl'
let g:hier_highlight_group_qfw = 'qf_warning_ucurl'

highlight qf_error_ucurl term=bold ctermfg=White ctermbg=Red gui=undercurl guisp=Red
highlight qf_warning_ucurl term=bold ctermfg=Black ctermbg=Yellow gui=undercurl guisp=Yellow

highlight DiffAdd term=bold ctermfg=Green ctermbg=DarkGreen guifg=Green
highlight DiffChange term=bold ctermfg=Blue ctermbg=DarkBlue guifg=Blue
highlight DiffDelete term=bold ctermfg=Magenta ctermbg=DarkRed guifg=Red
highlight DiffText term=bold ctermfg=Cyan ctermbg=DarkCyan guifg=White

Au VimEnter * call s:vimenter()
function! s:vimenter()
  NeoBundleCheck
  if !has('patch-7.4.414')
    NeoBundleSource
  endif
endfunction
if !has('vim_starting')
  call s:vimenter()
endif

" https://github.com/bronson/vim-trailing-whitespace
" http://d.hatena.ne.jp/thinca/20110810/1312913305

function! s:enable_auto_fix_trailing_whitespace()
  call s:disable_auto_fix_trailing_whitespace()
  autocmd my_vimrc_fix_trailing_whitespace BufWritePre * VimrcFixTrailingWhitespace
endfunction

function! s:disable_auto_fix_trailing_whitespace()
  augroup my_vimrc_fix_trailing_whitespace
    autocmd!
  augroup END
endfunction

function! s:fix_trailing_whitespace(range_given, line1, line2)
  if &filetype ==# 'markdown'
    return
  endif
  let save_pos = getpos('.')
  if a:range_given
    execute printf('%d,%ds/\v\\@<!(\s|\t|　)+$//e', a:line1, a:line2)
  else
    execute '%s/\v\\@<!(\s|\t|　)+$//e'
  endif
  call setpos('.', save_pos)
endfunction

command! -range=0 VimrcFixTrailingWhitespace call s:fix_trailing_whitespace(<count>, <line1>, <line2>)
command! VimrcFixTrailingWhitespaceEnable call s:enable_auto_fix_trailing_whitespace()
command! VimrcFixTrailingWhitespaceDisable call s:disable_auto_fix_trailing_whitespace()
VimrcFixTrailingWhitespaceEnable

" TODO
if has('vim_starting')
  set path-=,
endif

let s:t = {}

function! s:set_path(ft)
  let &l:path = &g:path
  let f = get(s:t, a:ft, {})
  if !empty(f)
    if !has_key(f, 'cache')
      let f['cache'] = f.get_path()
    endif
    for inc in f['cache']
      execute printf('setl path+=%s', inc)
    endfor
  endif
endfunction

Au FileType * call s:set_path(expand('<amatch>'))

function! s:include_paths(cmd, lang, opt)
  if !executable('echo') || !executable(a:cmd)
    return []
  endif

  let sep = has('unix') ? '|' : '\|'
  let cmd = printf('echo %s %s %s -Wp,-v -x %s - -fsyntax-only', sep, a:cmd, a:opt, a:lang)
  let incl_paths = systemlist(cmd)
  if type(incl_paths) == type('') && incl_paths ==# ''
    echom 'error:'.cmd
    return []
  endif

  let incl_start_idx = index(incl_paths,  '#include <...> search starts here:') + 1
  let incl_end_idx = index(incl_paths,  'End of search list.') - 1
  if incl_start_idx < incl_end_idx
    let result = incl_paths[incl_start_idx : incl_end_idx]
    return map(result, "fnameescape(substitute(v:val, '\v\C^\s+|\s+$', '', 'g'))")
  else
    return []
  endif
endfunction

let s:c_cmd = executable('gcc') ? 'gcc' : executable('clang') ? 'clang' :  ''

let s:t.c = {}
function! s:t.c.get_path()
  return s:include_paths(s:c_cmd, 'c', '')
endfunction

let s:t.cpp = {}
function! s:t.cpp.get_path()
  return s:include_paths(s:c_cmd, 'c++', '')
endfunction


" http://qiita.com/takaakikasai/items/3d4f8a4867364a46dfa3
if executable('git')
  set diffexpr=MyDiff()

  function! MyDiff()
    let v = s:my_diff(v:fname_in, v:fname_new)
    call writefile(split(v, '\n'), v:fname_out)
  endfunction

  function! s:my_diff(path1, path2)
    let diff_out = s:git_diff(a:path1, a:path2)
    return s:to_ed_format(diff_out)
  endfunction

  function! s:git_diff(path1, path2)
    let opt = &diffopt =~# 'iwhite' ? '-b' : ''
    let cmd = printf('git diff --histogram --no-index --no-color -U0 %s %s %s', opt, a:path1, a:path2)
    return system(cmd)
  endfunction

  function! s:action(bs, as)
    if a:bs ==# '0'
      return 'a'
    elseif a:as ==# '0'
      return 'd'
    else
      return 'c'
    endif
  endfunction

  function! s:range_str(start, size)
    let start = str2nr(a:start)
    let size = str2nr(a:size)
    if size == 0
      return string(start)
    else
      return printf('%d,%d', start, start+size-1)
    endif
  endfunction

  function! s:to_ed_change_command(a1, a2, a3, a4)
    let before_start = a:a1
    let before_size = a:a2
    let after_start = a:a3
    let after_size = a:a4

    let action = s:action(before_size, after_size)
    let before = s:range_str(before_start, before_size)
    let after = s:range_str(after_start, after_size)

    return printf('%s%s%s', before, action, after)
  endfunction

  function! s:to_ed_format(diff_out)
    let out = a:diff_out
    let out = substitute(out, '\v\C%^\_.{-}\ze\@\@', '', '')
    let out = substitute(out, '\M\C\n\zs+', '> ', 'g')
    let out = substitute(out, '\M\C\n\zs-', '< ', 'g')
    let out = substitute(out, '\v\C\@\@ -(\d+)(,(\d+))? \+(\d+)(,(\d+))? \@\@[^\n]{-}', '\=s:to_ed_change_command(submatch(1), submatch(3), submatch(4), submatch(6))', 'g')
    let out = substitute(out, '\M\C<[^\n]\{-}\n\zs>', '---\n>', 'g')
    return out
  endfunction
endif

let s:local_vimrc = s:vimdir('local_vimrc')
execute 'nnoremap' '[prefix]el' ':e' s:local_vimrc.'<CR>'
if filereadable(s:local_vimrc)
  execute 'source' s:local_vimrc
endif

